---
title: "openarchaeoCollaboration"
author:
  - name: Zack Batist
    url: https://zackbatist.github.io
    affiliation: University of Toronto
  - name: Joe Roe
    url: https://joeroe.io
    affiliation: University of Copenhagen
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	layout = "l-body-outset"
)
```

```{r dependencies, include=FALSE}
library("tidyverse")
library("lubridate")
library("openarchaeoCollaboration")
library("khroma")
library("gt")
```

```{r plot-theme}
theme_oarch <- function() theme(
  text = element_text(family = "Lato")
)
```

## Introduction

Research objectives and questions:

* What types of open source projects are being developed by archaeologists?
  * How many projects are there?
  * What do they do?
  * What languages are they written in and/or what platform do they use?
  * How has this changed over time?
* To what extent to these projects leverage tools for collaborative software engineering?
  * How many entries use version control?
  * How many entries have an explicit license?
  * What are the most popular licenses?
  * What are the most popular repository hosts?
  * How active is the average repository?
  * How fast have repositories been growing?
  * How many people contribute to individual repositories?
  * What roles do contributors to repositories have?
  * Are networks of collaboration emerging?
  * Contributions over time: is open source software in archaeology growing?
  * How frequently used are forks, pull requests, issues, and comments used?
  * How frequently used are 'engagement' features like stars, follows, and releases?
  * Collaboration over time: is the use of these features becoming more common?
* Does collaboration in software development mirror, or differ from, collaborative practices in archaeological research more broadly?

In applying either physical or digital methods, archaeology has a long tradition of adopting common or 'off the shelf' tools, and leveraging them in ways to serve our own unique needs that are typically unanticipated by their original designers.

A lot of this is surely due to resourcing and budgeting constraints, but holding prerequisite knowledge to create new tools, specifically designed for archaeology, may be a significant factor as well.

And while most archaeologists are probably content to outsource the metallurgical skills needed to forge their trowels, an increasingly large number of us are able to code our own programs and libraries, which serve functions that warrant archaeological input and initiative.

In fact, archaeologists are prolific programmers, as this paper will demonstrate.

Here, we present a survey of archaeological software development with a couple goals in mind.

First, we want to see what kinds of software archaeologists are making, and for what general purposes.

And second, we are interested in seeing how archaeologists collaborate in their programming work, and experience open source development processes, which have their own benefits, challenges and organizing principles that may conflict with or relate to means of collaboration and sharing that archaeologists are already generally accustomed to.

In this sense, we want to see how archaeological software is benefitting from, or missing out on, the affordances that open source development models -- particularly, the value added by a broader community of invested stakeholders, the pragmatic implementation of iterative updates, and increased transparency -- and consider how our own unique software development culture emerged and continues to grow.


## Background

- Lots of reviews out there on sets of tools geared towards specific kinds of applications
  - i.e. for aerial photo recognition, for photogrammetry, for tablet data collection, etc

- A few papers encouraging use of open source tools and platforms
  - @schmidt2020, @ducke2012, @orengo2015, @ducke2015, @ross2015, @wells2015

- @jeffrey2012, @beck2012, @bevan2012 on the new kinds of engagements and commitments that openness entails
  - @hansen2019 on the structural/systemtic challenges involved in maintaining a proper archaeological database
  - @parsons2013, @kansa2014a on carrying over existing ideas and modes of production

- On community-building
  - @carman2017 on the community-building and @carman2006 on the social practice of digging; we might extend this to discuss extended network of archaeological practices, which now includes software development
  - @morgan2012, @richardson2017b, @huggett2004 on encouraging wider participation within open collaboration networks
  - @morgan2015 and @caraher2019 on anarchic ethos in archaeology, see also responses by @richardson2017; we might draw parallels with similar worldviews in open source software development (i.e. hacker and DIY culture)
  - @sholler2019 wrote a general guide for encouraging participation within open source research projects (but not as an archaeologist)

- @daems2020 on educating students to use digital tools, and @morgan2018a on problems with making tools easy to use (relates to @caraher2015's value of friction)
  - Might also draw from @graham2019 and @graham2020 on pedagogical and exploratory aspects of hacking away

## Materials and methods

We used *open-archaeo* <https://open-archaeo.info/>, a list of open source archaeological software and other digital resources. As of June 8, 2021, 401 items are listed. Items are included in open-archaeo if a project is identified by its maintainers as relating to archaeological work.

The dataset was compiled by browsing collaborative software development platforms, essentially manually crawling through the profiles of users who identify as archaeologists or who have contributed to tools that pertain to archaeological work. This quasi-systematic collection strategy was also supplemented by contributions made by interested individuals who identified relevant work that was initially overlooked.

Open-archaeo is a relatively comprehensive list, however it generally lacks code written before the growth and general use of collaborative software development platforms among archaeologists (which seems to have began during the early-2010s) and code that is not available on the web. Additionally, items pertaining to various specialist domains may be spotty, owing to the limited experiences of the list's primary maintainers. To help resolve this issue, open-archaeo has put out a call specialists to perform 'deep dives' into the software ecosystems pertaining to their methodological or subject domains. Thus far, one 'deep dive' into tools used in archaeogenetics has been initiated.

```{r data-oarch}
read_csv("https://raw.githubusercontent.com/zackbatist/open-archaeo/master/open-archaeo.csv") %>%
  mutate(category = na_if(category, "?")) ->
  oarch

# Extract clean repos from GitHub URLs
oarch %>% 
  mutate(
    gh_repo = str_match(oarch$github, "^https://github.com/([\\w-\\.]+/[\\w-\\.]+)/?.*?$")[,2]
  ) ->
  oarch

# Amalgamate categories into fewer rough categories
# TODO: redo
oarch <- mutate(oarch, rough_category = recode(category,
                                 "R" = "Packages (R, Python, etc.)",
                                 "Web apps" = "Standalone apps",
                                 "Datasets" = "Analyses & datasets",
                                 "Tutorials" = "Lists & tutorials",
                                 "Python" = "Packages (R, Python, etc.)",
                                 "Desktop apps" = "Standalone apps",
                                 "QGIS" = "Plugins",
                                 "Lists" = "Lists & tutorials",
                                 "Mobile apps" = "Standalone apps",
                                 "Analyses" = "Analyses & datasets",
                                 "Spreadsheets" = "Forms & spreadsheets",
                                 "Command line tools" = "Standalone apps",
                                 "Plugins" = "Plugins",
                                 "ArcGis" = "Plugins",
                                 "Filemaker" = "Plugins",
                                 "ODK" = "Forms & spreadsheets",
                                 "Lisp" = "Packages (R, Python, etc.)",
                                 .default = "Other",
                                 .missing = "Other"
                                 ))
```

We augmented this with data from the GitHub API for records with an associated GitHub repository.

```{r data-github}
# Warning: slow
oarch <- mutate(oarch,
                gh_langs = map(oarch$gh_repo, gh_lang),
                gh_contribs = map(oarch$gh_repo, gh_contrib),
                gh_issues = map(oarch$gh_repo, gh_issue),
                gh_comments = map(oarch$gh_repo, gh_comment),
                gh_commits = map(oarch$gh_repo, gh_commit)
)
```

Each record is also annotated with tags that describe the aspects of archaeological work that each tool contributes to. Items are tagged based on how they have been identified or presented by their maintainers. The list of tags and their associated definitions is subject to grow or change as archaeologists continue to develop software for additional use cases.

Records are also categorized based on how each tool or resource is accessed or used. This gives us a sense of the pervasiveness of various development models, and the requirements or dependent knowledge that devs impose on their users.

Two kinds of categories have been defined: software and documents. Software comprise collections of instructions that dictate how a computer should operate. Documents are bounded sets of recorded information. Three categories of software and four categories of documents are defined below.

|Category|Kind|Scope|
|:-------|:---|:----|
|Packages and libraries|Software|Sets of functions assembled with clear purpose, and made accessible using standards established by an underlying platform.|
|Standalone software|Software|Software that may be operated without needing to first access an underlying platform.|
|Scripts|Software|Sets of pragmatically assembled mutable functions, often lacking complete documentation or adherence to protocols that would otherwise facilitate secondary use outside their original contexts of creation.|
|Specifications, protocols and schemas|Documents|A formal data structure or framework intended to be used as a model.|
|Products|Documents|Stable outcomes of creative work.|
|Guides|Documents|An educational resource or documented protocol meant to instruct readers how to apply relevant tools or techniques.|
|Lists and datasets|Documents|A series of consistently organized observations assembled with purpose.|

## Results

### Open archaeology

#### Categories, tags, and platforms

So let's start by breaking down the data set.

This plot indicates that most projects included in open-archaeo are designed to be used as a package or library atop a platform. The designers of this code are basically creating missing functions within the base platform that are useful for archaeological purposes. Some are also creating software to be run independently of any platform. A significant amount of projects also comprise of datasets and non-packaged code snippets that have been made available for general use.

```{r plot-categories}
oarch <- mutate(oarch, 
                category = recode(category,
                                  "Specifications, protocols and schemas" = "Specifications etc.",
                                  .default = category))
oarch %>%
  drop_na(category) %>%
  group_by(category) %>%
  summarise(n = n()) %>%
  ggplot(aes(fct_reorder(category, n), n)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Most popular categories",
    subtitle = "By number of projects",
    caption = "Data: open-archaeo.info",
    x = NULL, y = NULL
  ) +
  theme_oarch()

# Export for slides (half slide)
# ggsave("figures/categories.png", width = 127, height = 127, units = "mm")
```

```{r plot-platforms}
oarch %>%
  drop_na(platform) %>%
  group_by(platform, author1_name) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  mutate(total = sum(n)) %>% 
  ggplot(aes(fct_reorder(platform, total), n, group = author1_name)) +
  geom_col(colour = "#333333") +
  coord_flip() +
  labs(
    title = "Most popular platforms",
    subtitle = "By number of projects, split by primary author",
    caption = "Data: open-archaeo.info",
    x = NULL, y = NULL
  ) +
  theme_oarch()

# Export for slides (half slide)
# ggsave("figures/platforms.png", width = 127, height = 127, units = "mm")
```

R is overwhelmingly dominant as a platform, closely followed by Python.
Plugins for QGIS and mobile apps are also relatively popular.
The remainder show a rather fragmented landscape of plugins for other desktop software (e.g. AutoCAD, ArcGIS); lesser used programming languages; and custom form and spreadsheet templates.

When we break it down by number of unique contributors, we can account for the popularity of a platform in terms of share of the general population, regardless of how prolific their user-base is.

If we compare categories with tags, we can see the general domains that each kind of resource is designed to serve.

ZB: Compare tags with categories, to see the purposes of standalone software, datasets, guides, etc.

If we look at tags on their own, we can see which domains of archaeological research software is primarily being developed for. However, many items listed in open-archaeo have more than one tag. Based on an analysis of the co-occurence of tags, we infer that [...].

```{r plot-tags, fig.asp=2}
# Tags to be excluded as overly detailed/duplicating others
detail_tags <- c("Instrumental Neutron activation analysis",
                 "Harris Matrix",
                 "aDNA Simulators",
                 "Damage profilers",
                 "Metagenomic classifers",
                 "aDNA simulators",
                 "aDNA damage-aware genotypers",
                 "Low-coverage contamination estimation",
                 "Low-coverage adapted population-genetics tools",
                 "aDNA preprocessing",
                 "aDNA aligner",
                 "aDNA assembler",
                 "aDNA toolkit")

oarch %>%
  pivot_longer(c(tag1, tag2, tag3, tag4, tag5), values_to = "tag",
               values_drop_na = TRUE) %>%
  drop_na(tag) %>%
  filter(!tag %in% detail_tags) %>% 
  group_by(tag) %>% 
  summarise(n = n()) %>%
  ggplot(aes(fct_reorder(tag, n), n)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Most popular tags",
    caption = "Data: open-archaeo.info",
    x = NULL, y = "Number of projects"
  )
```

```{r plot-tags-cats}
oarch %>%
  pivot_longer(c(tag1, tag2, tag3, tag4, tag5), values_to = "tag",
               values_drop_na = TRUE) %>%
  drop_na(tag) %>%
  filter(!tag %in% detail_tags) %>% 
  mutate(category = recode(category,
                                  "Specifications etc." = "Documents",
                                  "Products" = "Documents",
                                  "Guides" = "Documents",
                                  "Lists and datasets" = "Documents",
                                  .default = category)) %>% 
  group_by(tag, category) %>% 
  summarise(n = n(), .groups = "drop_last") %>%
  mutate(total = sum(n)) %>% 
  ggplot(aes(fct_reorder(tag, total), n, fill = category)) +
  # facet_wrap(vars(category)) +
  geom_col() +
  scale_fill_bright() +
  coord_flip() +
  labs(
    title = "Tags by category",
    caption = "Data: open-archaeo.info",
    x = NULL, y = "Number of projects",
    fill = NULL
  ) +
  theme_oarch() +
  theme(
    axis.text.y = element_text(size = 7)
  )

# Export for slides (full slide)
# ggsave("figures/tags-cats.png", width = 254, height = 127, units = "mm")
```

```{r plot-tags-combo}
# NB. Plot in a big window if you want to actually read this!
oarch %>%
  pivot_longer(c(tag1, tag2, tag3, tag4, tag5), values_to = "tag",
               values_drop_na = TRUE) %>%
  select(item_name, tag) %>% 
  left_join(., ., by = "item_name") %>% # Join to self
  group_by(tag.x, tag.y) %>% 
  count() %>% 
  filter(tag.x != tag.y) %>% 
  ggplot(aes(tag.x, tag.y, label = n)) +
  geom_tile(fill = "black") +
  geom_text(colour = "white") +
  scale_fill_davos(guide = guide_none()) +
  coord_fixed() +
  labs(title = "Co-occurrence of tags",
       caption = "Data: open-archaeo.info",
       x = NULL, y = NULL) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1)
  )
```

We also plotted the development of new software over time.

ZB: Do a temporal analysis to get a sense of when platforms, tags and categories have been gaining popularity. There may not be a need for extreme detail here, but simply noting the dates of first commits might be helpful. I'm imagining a stacked bar chart, with each bar representing a month or a year, and with the stacked portions of each bar representing a platform or category.

#### Languages and platforms

TODO: Do we need to use this data, given it says much the same as the 'platform' taxonomy?

The GitHub API provides data on the languages used in a repository based on an automated machine learning algorithm.
Since most repositories use more than one language—if only one for the actual software, and another (e.g. HTML) for documentation—this data is presented as a table of languages and the number of bytes of code in that language detected in the repository.
We can therefore measure the popularity of languages across repositories in a couple of ways: based on how many repositories use a language at all; or based on how many bytes of that language are present.

```{r plot-gh_langs, fig.show="hold", out.width="50%"}
oarch %>%
  unnest(gh_langs) %>%
  drop_na(lang, bytes) %>%
  group_by(lang) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(-n) %>%
  slice(1:10) %>%
  ggplot(aes(fct_reorder(lang, n, .desc = TRUE), n)) +
  geom_col() +
  labs(title = "Repository languages",
       subtitle = "Number of repositories using top 10 languages",
       caption = "Data: open-archaeo.info and GitHub API",
       x = NULL, y = "Number of repositories")

oarch %>%
  unnest(gh_langs) %>%
  drop_na(lang, bytes) %>%
  group_by(lang) %>%
  summarise(bytes = sum(bytes), .groups = "drop") %>%
  arrange(-bytes) %>%
  slice(1:10) %>%
  ggplot(aes(fct_reorder(lang, bytes, .desc = TRUE), bytes)) +
  geom_col() +
  labs(title = "Repository languages",
       subtitle = "Total bytes of code in top 10 languages",
       caption = "Data: open-archaeo.info and GitHub API",
       x = NULL, y = "Bytes")
```

Looking at number of bytes puts C++ and the web languages (HTML, PHP, and Javascript) on top, but this is probably affected by the relative verboseness of these languages and the popularity of web-based documentation across implementation languages. The number of repositories is probably more reliable and shows the popularity of scientific programming languages—R and Python—followed by web languages and then compiled C and C++.

This largely confirms the pattern seen in our manual classification of the 'platform' of each project.

#### Version control

All projects included in open-archaeo make their source code available in some form, by definition.
But not all make use of version control.

```{r plot-repo-hosts}
oarch <- mutate(oarch, none = ifelse(is.na(github) & 
                                       is.na(gitlab) & 
                                       is.na(bitbucket) & 
                                       is.na(launchpad) & 
                                       is.na(codeberg),
                                     "", NA))

oarch %>% 
  pivot_longer(c(github, gitlab, bitbucket, launchpad, codeberg, none),
               names_to = "repo_host", values_to = "repo_url") %>% 
  drop_na(repo_url) %>% 
  group_by(repo_host, author1_name) %>% 
  summarise(n = n(), .groups = "drop_last") %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(repo_host = fct_reorder(repo_host, total),
         repo_host = fct_relevel(repo_host, "none")) %>% 
  ggplot(aes(repo_host, n, group = author1_name)) +
  geom_col(colour = "#333333") +
  coord_flip() +
  labs(title = "Most popular repository hosts",
       subtitle = "By number of projects, split by primary author",
       caption = "Data: open-archaeo.info",
       x = NULL, y = NULL)

# Export for slides (half slide)
# ggsave("figures/repo-hosts.png", width = 127, height = 127, units = "mm")
```

Amongst those that do use version control, the vast majority are hosted on GitHub, but a few other hosts are used too. Codeberg is a distant second-place in terms of popularity, but this is largely driven by a single active author. 

```{r table-no-repo}
# TODO: prettify with gt()
filter(oarch, none == "") %>% 
  count(category)
```

About one in eight projects do not use one of these repository host.
Some may use a different host, or not make their repositories publicly available, but it is probably safe to assume that the majority simply do not use version control.
Many of these are standalone documents or code fragments (scripts) hosted, for example, as 'gists', but there are also some pieces of standalone software that apparently do not include version control.

#### Repository lifespan and activity

The next set of analyses relies on the GitHub API to assess the leverage data about the activity occurring within each repository. To simplify our analysis and maintain a consistent dataset for the subsequent set of analyses, we excluded data from other hosts such as Codeberg or BitBucket, which cumulativey amount to only n items (XX% of the total).

```{r plot-gh_commits-cum}
oarch %>%
  unnest(gh_commits) %>%
  drop_na(sha) %>%
  mutate(date = floor_date(datetime, "week")) %>%
  mutate(lumped_category = recode(category,
                                  "Specifications etc." = "Documents",
                                  "Products" = "Documents",
                                  "Guides" = "Documents",
                                  "Lists and datasets" = "Documents",
                                  .default = category)) %>% 
  group_by(lumped_category, date) %>%
  summarise(n_commits = n(), .groups = "drop_last") %>%
  mutate(cat_total = sum(n_commits)) %>%
  mutate(cum_commits = cumsum(n_commits)) %>%
  ggplot(aes(date, cum_commits,
             fill = fct_reorder(lumped_category, cat_total),
             colour = fct_reorder(lumped_category, cat_total))) +
  geom_area() +
  scale_x_datetime(limits = c(ymd("2005-01-01", tz = "UTC"), 
                              ymd("2021-05-31", tz = "UTC")),
                   date_breaks = "2 years",
                   date_labels = "%Y") +
  scale_y_continuous(labels = scales::comma) +
  scale_colour_bright(guide = NULL) +
  scale_fill_bright(guide = guide_legend(reverse = TRUE)) +
  labs(
    title = "Growth of open archaeology",
    subtitle = "Measured by cumulative commits in GitHub repositories",
    caption = "Data: open-archaeo.info and GitHub API",
    x = NULL, y = NULL, fill = NULL
  ) +
  theme_oarch()

# Export for slides (full slide)
# ggsave("figures/commits-cum.png", width = 254, height = 127, units = "mm")
```

Use of GitHub has been growing consistently since around 2014, but how is this activity distributed across repositories?

We found that the mean/median/mode lifespan of a project is XX months. Projects that have had some activity during the past 3 months have ages ranging from XX-YY months ago.

ZB: Add columns to the right of the project lifespan plot with values showing commits per day, number of unique contributors, number of days between first and last commit, and any other relevant variables. Then discuss relationships between these variables.

```{r plot-lifespan}
oarch %>% 
  unnest(gh_commits) %>% 
  drop_na(datetime) %>% 
  group_by(item_name) %>%
  add_tally() %>% 
  filter(n > 1) %>% 
  mutate(first_commit = min(datetime),
         mid_commit = median(datetime),
         last_commit = max(datetime)) %>%
  ggplot(aes(x = fct_reorder(item_name, last_commit, .desc = FALSE),
             y = datetime,
             ymin = first_commit,
             ymax = last_commit)) +
  geom_linerange(size = 0.05) +
  geom_point(size = 0.1) +
  scale_y_datetime(limits = c(ymd("2005-01-01", tz = "UTC"), 
                              ymd("2021-05-31", tz = "UTC")),
                   date_breaks = "2 years", date_labels = "%Y") +
  # coord_flip() +
  labs(
    title = "Project lifespan",
    subtitle = glue("Individual commits in GitHub repositories (with more than 1 commit)"),
    x = NULL, y = NULL,
    caption = "Data: open-archaeo.info and GitHub API"
  ) +
  theme_oarch() +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_blank()
  )

# Export for slides (full slide)
# ggsave("figures/lifespan.png", width = 254, height = 127, units = "mm")
```

So we can see the "lifespan" and activity varies across repositories.
But how exactly?

```{r lifespan-stats}
oarch %>% 
  unnest(gh_commits) %>% 
  drop_na(datetime) %>% 
  group_by(item_name) %>%
  mutate(n_contribs = map_int(gh_contribs, vctrs::vec_size)) %>% 
  summarise(
    category = first(category),
    n_contribs = first(n_contribs),
    n = n(),
    first_commit = min(datetime),
    last_commit = max(datetime),
    lifespan = as.integer(last_commit - first_commit),
    commit_rate = n / lifespan
  ) ->
  oarch_lifespan
```

```{r plot-lifespan-hist}
oarch_lifespan %>% 
  ggplot(aes(x = lifespan)) +
  geom_histogram(binwidth = 100) +
  scale_x_continuous(breaks = scales::breaks_width(1000)) +
  labs(
    title = "Project lifespan",
    subtitle = "Time between first and latest commit, by repository",
    x = "Days", y = NULL,
    caption = "Data: open-archaeo.info and GitHub API"
  ) +
  theme_oarch()

# Export for slides (half slide)
# ggsave("figures/lifespan-hist.png", width = 127, height = 127, units = "mm")
```

```{r plot-lifespan-hist-byyear}
oarch_lifespan %>% 
  mutate(first_commit = year(first_commit)) %>% 
  filter(first_commit %in% 2012:2020) %>% 
  ggplot(aes(x = lifespan)) +
  facet_wrap(vars(first_commit), nrow = 1) +
  geom_histogram(binwidth = 100) +
  scale_x_continuous(breaks = scales::breaks_width(1000)) +
  labs(
    title = NULL,
    subtitle = NULL,
    x = NULL, y = NULL,
    caption = "Data: open-archaeo.info and GitHub API"
  )
```

```{r plot-rate-hist}
oarch_lifespan %>% 
  ggplot(aes(x = commit_rate)) +
  geom_histogram() +
  labs(
    title = "Project activity",
    subtitle = "Average commit rate",
    x = "Commits per day", y = "Repositories",
    caption = "Data: open-archaeo.info and GitHub API"
  )
```

What are the characteristics of long-lived and/or active repositories?

Projects with a short span of activity tend to have very high commit frequency, whereas there is much more variety in long-term projects. Among projects with a greater lifespan, those with more total commits have much more frequent activity than those with fewer total commits, which represent the majority of long-lived projects.

Some of this can be explained in terms of natural processes (i.e. the only way to fit a high number of commits within the same span as a project with a low number of commits is to commit more frequently)

But when we break it down by number of contributors [...]

```{r plot-lifespan-vs-rate}
oarch_lifespan %>% 
  ggplot(aes(x = lifespan, y = commit_rate, size = n)) +
  geom_point(shape = 21, fill = NA) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "Project lifespan vs. average commit rate",
    x = "Lifespan (days)", y = "Commits per day", size = "Total commits",
    caption = NULL
  ) +
  theme_oarch()
# Export for slides (half slide)
# ggsave("figures/lifespan-vs-rate-total.png", width = 127, height = 60, units = "mm")

oarch_lifespan %>% 
  ggplot(aes(x = lifespan, y = commit_rate, size = n_contribs)) +
  geom_point(shape = 21, fill = NA) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = NULL,
    x = "Lifespan (days)", y = "Commits per day", size = "Contributors",
    caption = "Data: open-archaeo.info and GitHub API"
  ) +
  theme_oarch()
# Export for slides (half slide)
# ggsave("figures/lifespan-vs-rate-contrib.png", width = 127, height = 60, units = "mm")

```

The measures of activity may also be compared with the tags.

```{r plot-lifespan-activity-tags}
left_join(oarch_lifespan, oarch, by = c("item_name")) %>% 
  pivot_longer(c(tag1, tag2, tag3, tag4, tag5), values_to = "tag",
               values_drop_na = TRUE) %>%
  drop_na(tag) %>% 
  group_by(tag) %>%
  summarise(avg_lifespan = mean(lifespan),
            avg_commit_rate = mean(commit_rate)) ->
  oarch_lifespan_by_tag

oarch_lifespan_by_tag %>% 
  arrange(-avg_lifespan) %>% 
  slice(1:10) %>% 
  ggplot(aes(x = fct_reorder(tag, avg_lifespan, .desc = TRUE),
             y = avg_lifespan)) +
  geom_col() +
  labs(
    title = "Project lifespan by tag",
    subtitle = "Top 10 longest-lived tags",
    x = NULL, y = "Average lifespan (days)",
    caption = "Data: open-archaeo.info and GitHub API"
  )

oarch_lifespan_by_tag %>% 
  arrange(-avg_commit_rate) %>% 
  slice(1:10) %>% 
  ggplot(aes(x = fct_reorder(tag, avg_commit_rate, .desc = TRUE),
             y = avg_commit_rate)) +
  geom_col() +
  labs(
    title = "Project activity by tag",
    subtitle = "Top 10 most activity tags",
    x = NULL, y = "Average activity (commits per day)",
    caption = "Data: open-archaeo.info and GitHub API"
  )
```

```{r plot-lifespan-activity-cats}
#TODO: Eliminate Infs

left_join(oarch_lifespan, oarch, by = c("item_name")) %>% 
  drop_na(category) %>% 
  group_by(category) %>%
  summarise(avg_lifespan = mean(lifespan),
            avg_commit_rate = mean(commit_rate)) ->
  oarch_lifespan_by_cat

oarch_lifespan_by_cat %>% 
  arrange(-avg_lifespan) %>% 
  slice(1:10) %>% 
  ggplot(aes(x = fct_reorder(category, avg_lifespan, .desc = TRUE),
             y = avg_lifespan)) +
  geom_col() +
  labs(
    title = "Project lifespan by category",
    subtitle = "Top 10 longest-lived categories",
    x = NULL, y = "Average lifespan (days)",
    caption = "Data: open-archaeo.info and GitHub API"
  )

oarch_lifespan_by_cat %>% 
  arrange(-avg_commit_rate) %>% 
  slice(1:10) %>% 
  ggplot(aes(x = fct_reorder(category, avg_commit_rate, .desc = TRUE),
             y = avg_commit_rate)) +
  geom_col() +
  labs(
    title = "Project activity by categories",
    subtitle = "Top 10 most activity categories",
    x = NULL, y = "Average activity (commits per day)",
    caption = "Data: open-archaeo.info and GitHub API"
  )
```

TODO: ZB: Any ideas for other relevant factors? Lots of ways you could go here...

#### Growth

### Collaboration

TODO: For this we need **covariates**! Could be:

* Domain (tags and categories)
* Time
* Social aspects: e.g. centrality extracted from network analysis

#### Number of collaborators and roles

```{r plot-gh_contributors-histogram}
oarch %>%
  drop_na(gh_repo) %>%
  unnest(gh_contribs) %>%
  group_by(gh_repo) %>%
  summarise(n = n(), .groups = "drop") %>%
  ggplot(aes(x = n)) +
  geom_histogram() +
  scale_x_log10() +
  labs(
    title = "Repository contributors",
    x = "Number of contributors", y = "Repositories",
    caption = "Data: open-archaeo.info and GitHub API"
  ) +
  theme_oarch()

# Export for slides (half slide)
# ggsave("figures/contrib-hist.png", width = 127, height = 127, units = "mm")
```

```{r plot-contrib-dist}
oarch %>% 
  unnest(gh_contribs) %>% 
  drop_na(contributor) %>% 
  group_by(item_name) %>% 
  mutate(n_contributors = n()) %>% 
  filter(n_contributors > 1) %>% 
  mutate(big_boy = ifelse(contributions == max(contributions), 
                          "Main contributor", "Other contributors")) %>% 
  ggplot(aes(x = item_name, y = contributions, 
             group = contributor,
             fill = big_boy)) +
  geom_col(position = "fill", colour = "white") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Repository", y = "Contributions",
       fill = NULL) +
  coord_flip() +
  theme_oarch() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

# Export for slides (half slide)
# ggsave("figures/contrib-dist.png", width = 127, height = 127, units = "mm")
```

#### Forks and pull requests

#### Issues and comments

```{r plot-gh_issues-histogram}
oarch %>%
  unnest(gh_issues) %>%
  drop_na(title) %>%
  group_by(repo) %>%
  summarise(n = n(), .groups = "drop") %>%
  ggplot(aes(x = n)) +
  geom_histogram(binwidth = 1) +
  labs(
    title = "Repository issues",
    caption = "Data: <https://open-archaeo.info> and the GitHub API",
    x = "Number of issues", y = "Number of repositories"
  )
```

ZB: How could we compare number of commits with number of issues? Some sort of coefficient, like commits divided by issues? Would this even be valuable at all?

#### Collaborative networks

If we construct a network linking repositories by their common contributors, can we identify emerging networks of collaboration, or are individual projects still largely isolated? If there are networks, what characterises their links?

ZB: I'm speculating that there are going to be various users who have their fingers in many projects, and that those projects tend to be the most active. If this is the case, I would further speculate that these people hold a different attitude regarding authorship and the dividuality of projects that is more in sync with the collaborative capabilities of open source, which are at odds with traditional academic norms regarding how contributions are credited and how products are produced are disseminated.



